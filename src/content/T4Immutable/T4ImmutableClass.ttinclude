<#@ assembly Name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="$(TargetDir)T4Immutable.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="EnvDTE" #>
<#+
public class ClassInfo {
  public EnvDTE80.CodeClass2 CodeClass { get; }
  public EnvDTE80.CodeAttribute2 ImmutableAttribute { get; }
  public bool Immutable { get { return ImmutableAttribute != null; } }
  public List<PropInfo> RelevantProps { get; }
  public List<FieldInfo> RelevantFields { get; }
  public bool Generated { get; }
  public bool HasPostConstructor { get; }
  public ClassInfo ParentClass { get; }
  public StructInfo ParentStruct { get; }

  public bool ShouldBeProcessed {
    get {
      return Immutable && !Generated;
    }
  }
  
  public string Name { get { return CodeClass.Name; } } 
  public string FullName { get { return  CodeClass.FullName; } }
  public EnvDTE.CodeNamespace CodeNamespace { get { return CodeClass.Namespace; } } 
  public string GenericString { get; } 

  public string Namespace { 
    get {
      return CodeNamespace != null ? CodeNamespace.FullName : "";
    } 
  }

  public string TypeString { get { return "class"; } }

  public ClassInfo(CodeClass thisClass) {
    CodeClass = (EnvDTE80.CodeClass2)thisClass;

    const string T4ImmutableClassAttribute = nameof(T4Immutable) + "." + nameof(T4Immutable.ImmutableClassAttribute);
    ImmutableAttribute = FindAttribute(thisClass.Attributes, T4ImmutableClassAttribute) as EnvDTE80.CodeAttribute2;
    RelevantFields = thisClass.Members.OfType<CodeVariable>().Select(p => new FieldInfo(p)).Where(p => p.Relevant).ToList();
    RelevantProps = thisClass.Members.OfType<CodeProperty>().Select(p => new PropInfo(p)).Where(p => p.Relevant).ToList();
    foreach (var prop in RelevantProps) {
      prop.UpdateDefaultValue(RelevantFields);
    }
    Generated = FindAttribute(thisClass.Attributes, GeneratedAttribute) != null;
    GenericString = ExtractGeneric(FullName);

    var parentClass = CodeClass.Parent as EnvDTE80.CodeClass2;
    var parentStruct = CodeClass.Parent as EnvDTE80.CodeStruct2;
    ParentClass = parentClass == null ? null : new ClassInfo(parentClass);
    ParentStruct = parentStruct == null ? null : new StructInfo(parentStruct);

    HasPostConstructor = thisClass.Members.OfType<EnvDTE80.CodeFunction2>().Any(m => IsPostConstructor(m));
  }

  private static bool IsPostConstructor(EnvDTE80.CodeFunction2 m) {
    return m.Name == "PostConstructor";
  }

  private void ValidatePostConstructor(string fileName, EnvDTE80.CodeFunction2 m) {
    if (m.Name != "PostConstructor") 
      throw new T4ImmutableException(fileName, FullName, "Immutable class PostConstructor() has a wrong name (internal error)");

    if (m.IsGeneric) 
      throw new T4ImmutableException(fileName, FullName, "Immutable class PostConstructor() must not be generic");
    if (m.IsShared)
      throw new T4ImmutableException(fileName, FullName, "Immutable class PostConstructor() must not be static");
    if (m.Type.TypeKind != vsCMTypeRef.vsCMTypeRefVoid)
      throw new T4ImmutableException(fileName, FullName, "Immutable class PostConstructor() must return void");
    if (m.IsOverloaded)
      throw new T4ImmutableException(fileName, FullName, "Immutable class PostConstructor() must not have overloads");
    if (m.Parameters.Count > 0)
      throw new T4ImmutableException(fileName, FullName, "Immutable class PostConstructor() must have no parameters");
  }

  public void Validate(string fileName) {
    var thisClass = CodeClass;
    var partialClasses = VSH.CodeModel.GetPartialClasses(thisClass).Select(c => new ClassInfo(c)).ToList();

    // do not support static classes
    if (thisClass.IsShared) {
      throw new T4ImmutableException(fileName, FullName, "Immutable classes cannot be static");
    }

    // don't support partial immutable classes (not counting generated ones)
    // TODO: probably we should in the future
    {
      int partials = partialClasses.Count(c => !c.Generated);
      if (partials > 1) {
        throw new T4ImmutableException(fileName, FullName, "Immutable classes cannot be partial (but for generated partials)");
      }
    }

    // do not support base classes
    // TODO: maybe we should in the future? maybe only base classes with constructors without args?
    var baseClass = VSH.CodeModel.GetBaseClass(CodeClass);
    if (baseClass != null && baseClass.FullName != "System.Object") {
      throw new T4ImmutableException(fileName, FullName, "Immutable classes cannot have a base class");
    }

    // no constructors allowed
    var memberFuncs = thisClass.Members.OfType<CodeFunction>().ToList();
    var constructors = memberFuncs.Where(m => m.FunctionKind == vsCMFunction.vsCMFunctionConstructor).ToList();
    if (constructors.Count > 0) {
      throw new T4ImmutableException(fileName, FullName, "Immutable classes cannot have constructors (but for generated ones)");
    }

    if (HasPostConstructor) {
      foreach (var m in CodeClass.Members.OfType<EnvDTE80.CodeFunction2>().Where(m => IsPostConstructor(m))) {
        ValidatePostConstructor(fileName, m);
      }
    }

    // validate each field
    foreach (var field in RelevantFields) {
      field.Validate(fileName);
    }

    // validate each property
    foreach (var prop in RelevantProps) {
      prop.Validate(fileName);
    }
  }

  public void MarkAsPartial() {
    if (CodeClass.DataTypeKind != EnvDTE80.vsCMDataTypeKind.vsCMDataTypeKindPartial) {
      try {
        CodeClass.DataTypeKind = EnvDTE80.vsCMDataTypeKind.vsCMDataTypeKindPartial;
      }
      catch {
        AddWarning("Unable to mark class " + FullName + " as partial. Please change it manually if possible");
      }
    }
  }

}
#>