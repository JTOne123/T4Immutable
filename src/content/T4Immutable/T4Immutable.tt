<#@ template language="C#" debug="true" hostSpecific="true" #>
<#@ output extension=".log" #>
<#@ include file=".\VisualStudioHelper.ttinclude" #>
<#@ include file=".\TemplateFileManagerV2.1.ttinclude" #>
<#@ include file=".\Shared.ttinclude" #>
<#@ include file=".\Parser.ttinclude" #>
<#@ include file=".\Field.ttinclude" #>
<#@ include file=".\Prop.ttinclude" #>
<#@ include file=".\Struct.ttinclude" #>
<#@ include file=".\Class.ttinclude" #>
<#@ assembly Name="System.Core" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="EnvDTE" #>
<#
// To debug, uncomment the next two lines !! 
// Debugger.Launch();
// Debugger.Break();

var manager = TemplateFileManager.Create(this);
//manager.IsAutoIndentEnabled = true; // this makes generation unreliable (and slower) when set to true
manager.CanOverrideExistingFile = true;
var outFileNamesUsed = new HashSet<string>();

// init the parser
var curProject = VSH.CurrentProject;
var curProjectDir = System.IO.Path.GetDirectoryName(curProject.FullName);
Parser.ReadAttributesCs(curProjectDir);

var allProjectItems = VSH.GetAllProjectItems();
foreach (ProjectItem pitem in allProjectItems) {
  var fileName = pitem.Name;
  if (!fileName.ToLowerInvariant().EndsWith(".cs")) continue;

  var codeModel = pitem.FileCodeModel;
  if (codeModel == null || codeModel.CodeElements == null) continue;

  var classes = VSH.CodeModel.GetAllCodeElementsOfType(codeModel.CodeElements, vsCMElement.vsCMElementClass, false).OfType<CodeClass>();
  foreach (var thisClass in classes) {
    var info = new ClassInfo(thisClass);
    if (!info.ShouldBeProcessed) continue;

    var outFileName = info.Name;

    // find a proper filename four the output
    // in case the class is defined in several parts then we will use name, name-2, name-3, etc
    int number = 1;
    var realOutFileName = outFileName;
    while (outFileNamesUsed.Contains(realOutFileName.ToLowerInvariant())) {
      number++;
      realOutFileName = outFileName + "-" + number;
    }
    outFileNamesUsed.Add(realOutFileName.ToLowerInvariant());

    realOutFileName += ".generated.cs";

    manager.StartNewFile(realOutFileName);
    
    var fw = new ClassWriter();
    try {
      ProcessClass(fileName, info, fw);
    }
    catch (T4ImmutableException ex) {
      fw.Clear();
      WriteHeader(fw);
      fw.WI(0, "// Generation not done due to the following errors:");
      fw.WI(0, "// - " + ex.Message);

      AddError(ex.Message);
    }
    finally {
      fw.WriteOut();
    }
  }  
}

manager.Process();

#>
<#+
static void WriteHeader(ClassWriter fw) {
  fw.WI(0, "// <auto-generated />");
  fw.WI(0, "// This file was generated by T4Immutable");
  fw.WI(0, "// Don't change it directly as your change would get overwritten. Run T4Immutable.tt or \"Build - Transform All T4 Templates\" instead");
  fw.WI(0, "");
}

static void ProcessClass(string fileName, ClassInfo info, ClassWriter fw) {
  WriteHeader(fw);

  fw.WI(0, "using System;");
  fw.WI(0, "");

  int ind = 0;

  info.ProcessAndValidate();
  var allProps = info.RelevantProps;

  // make our partial class with all the boilerplate
  bool enableConstructor = info.EnableConstructor;
  bool enableEquals = info.EnableEquals;
  bool enableOperatorEquals = info.EnableOperatorEquals;
  bool enableGetHashCode = info.EnableGetHashCode;
  bool enableWith = info.EnableWith;
  bool enableToString = info.EnableToString;
  string constructorAccessLevel = info.ConstructorAccessLevel;
  bool allowCustomConstructors = info.AllowCustomConstructors;
  bool enableBuilder = info.EnableBuilder;
  string builderAccessLevel = info.BuilderAccessLevel;
  bool enableToBuilder = info.EnableToBuilder;

  // namespace
  var namesp = info.Namespace;
  bool hasNamesp = !string.IsNullOrWhiteSpace(namesp);
  if (hasNamesp) {
    fw.WI(ind, "namespace " + namesp + " {");
    ind++;
  }

  // get the list of parents
  var parents = new List<object>();
  {
    var currentClass = info.ParentClass;
    var currentStruct = info.ParentStruct;
    while (currentClass != null || currentStruct != null) {
      if (currentClass != null) {
        parents.Add(currentClass);

        // the order matters!
        currentStruct = currentClass.ParentStruct;
        currentClass = currentClass.ParentClass;
      }
      else {
        parents.Add(currentStruct);

        // the order matters!
        currentClass = currentStruct.ParentClass;
        currentStruct = currentStruct.ParentStruct;
      }
    }
  }
  parents.Reverse();

  // parent classes / structs
  foreach (var p in parents) {
    var pClass = p as ClassInfo;
    var pStruct = p as StructInfo;
    fw.WIGenerated(ind, false, false);
    if (pClass != null) {
      fw.WI(ind, "partial class " + pClass.Name + pClass.GenericString + " {");
    }
    else {
      fw.WI(ind, "partial struct " + pStruct.Name + pStruct.GenericString + " {");
    }
    ind++;
  }

  // type header
  {
    var interfaces = "";
    if (enableEquals) {
      interfaces = " : IEquatable<" + info.FullName + ">";
    }

    fw.WIGenerated(ind);
    fw.WI(ind, "partial " + info.TypeString + " " + info.Name + info.GenericString + interfaces + " {");
    ind++;
  }

  // constructor
  if (enableConstructor) {
    fw.WIGenerated(ind);
    if (!string.IsNullOrWhiteSpace(info.PreConstructor)) {
      fw.WI(ind, info.PreConstructor);
    }
    fw.WI(ind, constructorAccessLevel + " " + info.Name + "(" + string.Join(", ", allProps.Select(p => p.ToFullParam(true, true, true))) + ") {");
    ind++;
      
    // pre not-null checks
    foreach (var p in allProps.Where(p => p.PreNotNullCheck)) {
      fw.WI(ind, "if (ReferenceEquals(" + p.ParamName + ", null)) throw new ArgumentNullException(nameof(" + p.ParamName + "));");
    }

    // assignations
    foreach (var prop in allProps) {
      fw.WI(ind, "this." + prop.Name + " = " + prop.ParamName + ";");
    }

    // PostConstructor
    if (info.HasPostConstructor) {
      fw.WI(ind, "PostConstructor();");
    }

    // post not-null checks
    foreach (var p in allProps.Where(p => p.PostNotNullCheck)) {
      fw.WI(ind, "if (ReferenceEquals(this." + p.Name + ", null)) throw new NullReferenceException(nameof(this." + p.Name + "));");
    }

    fw.WI(ind, "_ImmutableHashCode = T4Immutable.Helpers.GetHashCodeFor(" + string.Join(", ", allProps.Select(p => "this." + p.Name)) + ");");

    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");
  }

  // Equals
  {
    fw.WIGenerated(ind);
    fw.WI(ind, "private bool ImmutableEquals(" + info.FullName + " obj) {");
    ind++;
    fw.WI(ind, "if (ReferenceEquals(this, obj)) return true;");
    fw.WI(ind, "if (ReferenceEquals(obj, null)) return false;");
    if (allProps.Count == 0) {
      fw.WI(ind, "return true;");
    }
    else {
      fw.WI(ind, "return " + string.Join(" && ", allProps.Select(p => CustomNamespace + ".Helpers.AreEqual(this." + p.Name + ", obj." + p.Name + ")")) + ";");
    }
    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");

    if (enableEquals) {
      fw.WIGenerated(ind);
      fw.WI(ind, "public override bool Equals(object obj) {");
      ind++;
      fw.WI(ind, "return ImmutableEquals(obj as " + info.FullName + ");");
      ind--;
      fw.WI(ind, "}");
      fw.WI(ind, "");

      fw.WIGenerated(ind);
      fw.WI(ind, "public bool Equals(" + info.FullName + " obj) {");
      ind++;
      fw.WI(ind, "return ImmutableEquals(obj);");
      ind--;
      fw.WI(ind, "}");
      fw.WI(ind, "");
    }
  }

  // operator==, operator!=
  if (enableOperatorEquals) {
      fw.WIGenerated(ind);
      fw.WI(ind, "public static bool operator ==(" + info.FullName + " a, " + info.FullName + " b) {");
      ind++;
      fw.WI(ind, "return T4Immutable.Helpers.BasicAreEqual(a, b);");
      ind--;
      fw.WI(ind, "}");
      fw.WI(ind, "");
      
      fw.WIGenerated(ind);
      fw.WI(ind, "public static bool operator !=(" + info.FullName + " a, " + info.FullName + " b) {");
      ind++;
      fw.WI(ind, "return !T4Immutable.Helpers.BasicAreEqual(a, b);");
      ind--;
      fw.WI(ind, "}");
      fw.WI(ind, "");
  }

  // GetHashCode
  {
    fw.WIGenerated(ind, false);
    fw.WI(ind, "private readonly int _ImmutableHashCode;");
    fw.WI(ind, "");
    fw.WIGenerated(ind);
    fw.WI(ind, "private int ImmutableGetHashCode() {");
    ind++;
    fw.WI(ind, "return _ImmutableHashCode;");
    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");

    if (enableGetHashCode) {
      fw.WIGenerated(ind);
      fw.WI(ind, "public override int GetHashCode() {");
      ind++;
      fw.WI(ind, "return ImmutableGetHashCode();");
      ind--;
      fw.WI(ind, "}");
      fw.WI(ind, "");
    }
  }

  // ToString
  {
    fw.WIGenerated(ind);
    fw.WI(ind, "private string ImmutableToString() {");
    ind++;
    fw.WI(ind, "return T4Immutable.Helpers.ToStringFor(nameof(" + info.Name + info.GenericString + "), " + string.Join(", ", allProps.Select(p => "new System.Tuple<string, object>(nameof(this." + p.Name + "), this." + p.Name + ")")) + ");") ;
    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");

    if (enableToString) {
      fw.WIGenerated(ind);
      fw.WI(ind, "public override string ToString() {");
      ind++;
      fw.WI(ind, "return ImmutableToString();");
      ind--;
      fw.WI(ind, "}");
      fw.WI(ind, "");
    }
  }

  // With
  {
    fw.WIGenerated(ind);
    fw.WI(ind, "private " + info.FullName + " ImmutableWith(" + string.Join(", ", allProps.Select(p => p.ToFullOptParam(true, true))) + ") {");
    ind++;
    fw.WI(ind, "return new " + info.FullName + "(");
    ind++;
    int i = 0;
    foreach (var p in allProps) {
      bool lastOne = i == allProps.Count - 1;
      fw.WI(ind, p.ParamName + ".HasValue ? " + p.ParamName + ".Value : this." + p.Name + (lastOne ? "" : ","));
      i++;
    }
    ind--;
    fw.WI(ind, ");");
    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");

    if (enableWith) {
      fw.WIGenerated(ind);
      fw.WI(ind, "public " + info.FullName + " With(" + string.Join(", ", allProps.Select(p => p.ToFullOptParam(true, true))) + ") {");
      ind++;
      fw.WI(ind, "return ImmutableWith(" + string.Join(", ", allProps.Select(p => p.ParamName)) + ");");
      ind--;
      fw.WI(ind, "}");
      fw.WI(ind, "");
    }
  }

  // ToBuilder
  if (enableToBuilder) {
    fw.WIGenerated(ind);
    fw.WI(ind, "public " + info.FullName + ".Builder ToBuilder() {");
    ind++;
    fw.WI(ind, "return ImmutableToBuilder();");
    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");
  }

  // Builder
  if (enableBuilder) {
    fw.WIGenerated(ind);
    fw.WI(ind, "private " + info.FullName + ".Builder ImmutableToBuilder() {");
    ind++;
    fw.WI(ind, "return new " + info.FullName + ".Builder().With(");
    ind++;
    int i = 0;
    foreach (var p in allProps) {
      bool lastOne = i == allProps.Count - 1;
      fw.WI(ind, "new " + p.ToOptParam() + "(this." + p.Name + ")" + (lastOne ? "" : ","));
      i++;
    }
    ind--;
    fw.WI(ind, ");");
    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");

    fw.WIGenerated(ind);
    fw.WI(ind, builderAccessLevel + " class Builder {");
    ind++;

    // properties
    foreach (var p in allProps) {
      fw.WIGenerated(ind);
      fw.WI(ind, "public " + p.ToFullOptParam(false, false) + " { get; set; }");
    }
    fw.WI(ind, "");

    // with method
    fw.WIGenerated(ind);
    fw.WI(ind, "public Builder With(" + string.Join(", ", allProps.Select(p => p.ToFullOptParam(true, true))) + ") {");
    ind++;
    foreach (var p in allProps) {
      fw.WI(ind, "if (" + p.ParamName + ".HasValue) this." + p.Name + " = " + p.ParamName + ";");
    }
    fw.WI(ind, "return this;");
    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");

    // build method
    fw.WIGenerated(ind);
    fw.WI(ind, "public " + info.FullName + " Build() {");
    ind++;
    // set defaults and check values
    foreach (var p in allProps) {
      if (p.DefaultValue != null) {
        fw.WI(ind, "if (!this." + p.Name + ".HasValue) this." + p.Name + " = " + p.DefaultValue.InitExpressionString + ";");
      }
      fw.WI(ind, "if (!this." + p.Name + ".HasValue) throw new InvalidOperationException(\"Builder property '" + p.Name + "' cannot be left unassigned\");");
    }
    fw.WI(ind, "return new " + info.FullName + "(" + string.Join(", ", allProps.Select(p => "this." + p.Name + ".Value")) + ");");
    ind--;
    fw.WI(ind, "}");

    ind--;
    fw.WI(ind, "}");
    fw.WI(ind, "");
  }

  // end of type header
  {
    ind--;
    fw.WI(ind, "}");
  }

  info.MarkAsPartial();

  // end of parent classes / structs
  foreach (var p in parents) {
    var currentClass = p as ClassInfo;
    var currentStruct = p as StructInfo;
    ind--;
    fw.WI(ind, "}");

    if (currentClass != null) {
      currentClass.MarkAsPartial();
    }
    else {
      currentStruct.MarkAsPartial();
    }
  }

  // end of namespace
  if (hasNamesp) {
    ind--;
    fw.WI(ind, "}");
  }
    
  fw.WI(ind, "");
}
#>